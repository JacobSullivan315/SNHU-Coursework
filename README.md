# SNHU-Coursework

CS  150
In this project, I was tasked with developing a program that allows a user to input different amounts for four variables concerning a bank account. The program then used those values to calculate and display how interest compounds in that account, with and without additional monthly deposits. 

Personally, I thought the organization of my classes into neat cpp files, each with h files, was done quite well. The code works efficiently, but the way I set it up allows for anyone to dive in and lter small pieces of the code while minimizing potential damage to the project as a whole if they made a mistake. Keeping these classes and functions separate also improves overall readability, as well.

I could definitely improve in writing more secure code. So far, I have a basic understanding of how C++ works, enough to get by writing simple programs such as this one. However, I know very little of writing code with security in mind. I look forward to learning more about this particular subject, but I feel I am sitll a bit too fresh to programming to approach writing these programs in a way that keeps potential online attacks on these programs in mind. 

At the time of writing this particular project, I was struggling very much with input validation. Specifically, if the user entered an input of the wrong data type. To solve this, I used a tutoring session via SNHU's 24/7 tutoring and they were able to break input validation down in a way the book couldn't for me. We went over a few different hypotheticals of how I would validate which kinds of input, and using this knowledge helped me not only finish this program, but improved my work for the rest of the course.

In terms of what skills I learned here that will help in the future, I would say on top of input validation is class/file organization. I really dove into using multiple files and headers here, challenging myself to learn how to do this effectively. I feel this will help me write neater, more organized, and more readable programs.


CS230 The Gaming Room

In this project, I was tasked with creating a software design document for a client called The Gaming Room. The client wanted to develop a web-based game based on their currently Android-exclusive game called Draw It or Lose It. The client wanted the game to have the ability to serve multiple clients on multiple platforms, such as web browsers and iPhones. The game software must also have the ability to choose from a large library of stock images to be used as visual clues for the users. These images must be rendered at a steady yet quick rate as to provide a seamless experience for the consumer. In addition to this function, the client requested that only one instance of a game may exist at once, that team names be unique with no duplicates permitted, that teams have the capability of having multiple players assigned to them, and that games must have the ability to involve multiple teams.

This project was certainly a challenge for me. I have grown in my ability to write efficient code in three languages. However, looking objectively at a piece of software before its development was a new experience for me. I think I did rather well on researching and comparing the benefits and drawbacks of different server hosts, such as Linux and Windows. It took some time to gather all the necessary knowledge to make an accurate assessment on which would best suit the client, but once I began piecing all of the information I learned together, looking at this side of development started to make a lot more sense to me. I believe I was able to effectively recommend the proper operating platform to host the server, the proper service to handle storage management, as well as describe how these choices will assist the client most and how they are most suitable for what the client needed. I also feel I did well describing the architecture of the Linux operating platform and explaining it in a manner that is easily understood by those who may not be very familiar with software development. 

Designing the UML diagram and analyzing the needs of the client in terms of software functionality were both quite helpful to me when writing the code. Being able to visualize the code through the UML diagram made it much easier to organize my classes and methods and ensure they worked together, not just as code, but in a way the client would be happy with. The software needs of the client helped me design these methods properly as I was able to keep in mind how the client wanted the code to work and flow as I figured out how exactly I would complete the code given to me. These two sections were my lifelines if I reached a point that I felt stuck or unsure.

If I could pick a section to revise, it would be design constraints. I am still uncomfortable with analyzing how the process of developing a software will affect the client in terms of variables such as budget or resources. It was difficult for me, as someone who's never worked in the field of tech, to grasp all of the elements that surround software design when I've only just learned to code. I still feel I would not be able to properly analyze the non-technical effects a software's development would have on the company designing it without a guiding hand. As I continue my studies I have no doubt that I will eventually have the knowledge to identify potential drawbacks of certain aspects of a program and how they may affect things outside the realm of the code itself.

The user is the most important person to keep in mind when developing any software because they are the one interacting with it. They are a potential consumer and no one wants to purchase a software that is slow, clunky, or hard to use. This played a major role when analyzing the proper operating platform to host, development tools available, and storage management companies to choose. The client wanted the game to run well on multiple platforms as well as quickly access a library of images to display to users enjoying their game. If these images were rendered slowly because of poor choice of storage managment or memory managment, or if the whole application was to crash on certain platforms regularly due to the use of a product n development not designed for cross platform development, the client would lose users and money. 

My approach with this project was simply one step at a time. The coding was not too difficult, but it seems most of the steps in a software design document involves market research, hardware research, and software research. Whenever I hit a road black, I would browse tech forums and pick the minds of tutors and other users on these forums alike to learn what I was not taking into account. This technique was one of my main take aways from this course overall. I may exhaustively look over all necessary aspects of a software design, but an outside perspective opens your eyes to much you may have overlooked. I surely will not shy away from asking for advice or opinions from those with experience in the industry in future courses and my career.

